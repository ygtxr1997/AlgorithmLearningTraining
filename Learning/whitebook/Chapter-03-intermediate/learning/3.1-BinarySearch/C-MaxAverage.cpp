// ---------------------------------------------------------------------
// 题目描述:
// 有 n 个物品的重量和价值分别是 wi 和 vi.
// 从中选出 k 个物品使得单位重量的价值最大.
// 1 <= k <= n <= 10000
// 1 <= wi, vi <= 1000000
// ---------------------------------------------------------------------
// 思路:
// 按照物品的单位价值升序排序, 然后从大到小贪心地取肯定是不对的.
// 定义 C(x):=可以选择 k 个物品使得单位重量的价值大于等于 x
// 假设选择的物品集合是 S, 为了判断 C(x) 是否成立,
// 即 Σ(i∈S)vi / Σ(i∈S)wi >= x 是否成立,
// 变形得 Σ(i∈S)(vi-x*wi) >= 0,
// 因此, 对于给定的 x, 按照 (vi-x*wi) 排序然后从大到小贪心地选取即可.
// 此时 C(x) = ((vi-x*wi)从大到小排列中的前k个的和是否大于等于0)
// 每次判断的时间复杂度是O(nlogn).
// ---------------------------------------------------------------------

// 输入
int n, k;
int w[maxn], v[maxn];
double y[maxn]; // v - x * w

// 判断是否满足条件
bool C(double x) {
    for (int i = 0; i < n; ++i) {
        y[i] = v[i] - x * w[i];
    }
    sort(y, y + n);

    // 计算最大的前k项和
    double sum = 0;
    for (int i = 0; i < k; ++i) {
        sum += y[n - i - 1];
    }

    return sum >= 0;
}

void solve(void) {
    double lb = 0, ub = INF;
    for (int i = 0; i < 100; ++i) {
        double mid = (lb + ub) / 2;
        if (C(mid)) lb = mid;
        else ub = mid;
    }
    printf("%.2f\n", ub);
}
