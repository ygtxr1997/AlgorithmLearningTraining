// -------------------------------------------------------------------------------------------------
// 图的割:
// 顶点集合S⊆V, 从S的顶点出发指向不属于S的其他顶点的那些边的集合, 记为割(S, V\S).
// 这些边的容量之和称为割的容量.
// -------------------------------------------------------------------------------------------------
// s-t割:
// 如果s∈S且t∈V\S, 此时的割又称为s-t割.
// 如果将网络中s-t割包含的边都删去, 就不存在s到t的路径了.
// -------------------------------------------------------------------------------------------------
// 最小割:
// 对于给定网络, 为了保证没有从s到t的路径, 需要删除的边的总容量的最小值是多少?
// 首先, 考虑任意的 s-t流f 和 s-t割(S,V\S), s∈S.
// 因为 (f的流量) = (s的出边的总流量),
// 而对 v∈S\{s}, 有 (v的出边的总流量) = (v的入边的总流量),
// 所以 (f的流量) = (S的出边的总流量) - (S的入边的总流量).
// 又 (割的容量) = (S的出边的总流量),
// 由此 (f的流量) <= (割的容量).    ------(1)
// 接下来, 考虑通过Ford-Fulkerson算法求得的流f'.
// 记流f'对应的残存网络中从s可达的顶点组成的集合为S, 因为f'对应的残存网络不存在s-t路径, 因此(S,V\S)就是s-t割.
// 此外, 根据S的定义, 对包含在割中的边e应有f'(e)=c(e), 而对从V\S到S的边e应有f'(e)=0.
// 因此 (f'的流量) = (S的出边的总流量) - (S的入边的总流量) = (割的容量).
// 再根据不等式(1), f'即最大流.
// 即证明了Ford-Fulkerson算法的正确性, 又推导出了最大流等于最小割.
// -------------------------------------------------------------------------------------------------
// 最大流多源点和汇点:
// 添加超级源点和超级汇点
// -------------------------------------------------------------------------------------------------
// 无向图:
// 无向边转化为两条有向边
// -------------------------------------------------------------------------------------------------
// 顶点上也有流量限制:
// 一点拆两点, 点限制转化为边限制
// -------------------------------------------------------------------------------------------------
// 最小流量限制:
// 添加源点S, 汇点T, c(S,s)=INF, c(t,T)=INF, c(S,v)=b, c(u,T)=b, c(u,v)=c-b
// -------------------------------------------------------------------------------------------------
// 图发生部分变化:
// 有时不需要重复计算最大流, 而可以利用前一步的结果.
// -------------------------------------------------------------------------------------------------
// 容量为负数:
// 目前没有已知的有效算法, 可以采取适当的变形避免出现负容量边.
// -------------------------------------------------------------------------------------------------
// 更高效的最大流算法:
// Ford-Fulkerson算法的复杂度为O(F|E|).
// Dinic算法复杂度是O(|E||V|^2), 不过该算法在实际应用非常快, 即便图的规模较大通常也没有问题.
// -------------------------------------------------------------------------------------------------

// 边结构体
struct edge {
    int to, cap, rev; // 终点, 容量, 反向边
};

vector<edge> G[maxv]; // 邻接表
int level[maxv]; // 顶点到源点的距离
int iter[maxv]; // 当前弧

// 添加边
void add_edge(int from, int to, int cap) {
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

// BFS计算到源点的距离
void bfs(int s) {
    memset(level, -1, sizeof(level));
    queue<int> que;
    level[s] = 0;
    que.push(s);
    while (!que.empty()) {
        int v = que.front();
        que.pop();
        for (int i = 0; i < G[v].size(); i++) {
            edge &e = G[v][i];
            if (e.cap > 0 && level[e.to] < 0) {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//  通过DFS寻找增广路
int dfs(int v, int t, int f) {
    if (v == t) return f;
    for (int &i = iter[v]; i < G[v].size(); ++i) {
        edge &e = G[v][i];
        if (e.cap > 0 && level[v] < level[e.to]) {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

// 求s到t的最大流
int max_flow(int s, int t) {
    int flow = 0;
    for (;;) {
        bfs(s);
        if (level[t] < 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
}
