// ---------------------------------------------------------------------
// 题目描述:
// N 头牛排成一排, 每头牛朝前或朝后, 为了让所有的牛都朝前, FJ 买了一台机器.
// 这台机器在购买时就必须设定一个数值 K, 机器每次恰好使 K 头连续的牛转向.
// 为了让所有的牛都朝前, 求出最少的操作次数 M 和对应的最小的 K.
// ---------------------------------------------------------------------
// 思路:
// 典型的反转(开关)问题.
// 1. 交换区间的反转顺序不影响结果
// 2. 同一区间最多只需要反转一次
// 3. 对于给定的 K, 先考虑第一头牛, 
//    如果这头牛面向前方, 那么不用反转;
//    如果这头牛面向后方, 就必须反转整个区间;
//    重复下去, 每次问题的规模减一, 重复 N 次即可求出结果.
//    总时间复杂度是 O(n^3).(枚举K, 反转K头牛, 遍历牛)
// 4. 对反转区间进行优化:
//    f[i] := 区间[i, i+K-1]进行了反转的话则为1, 否则为0
//    那么对于第 i 头牛, 如果 Σ(j=i-K+1, i-1)f[j] 为奇数, 则这头牛的方向与原来相反
//    又 Σ(j=(i+1)-K+1, i)f[j] = Σ(j=i-K+1, i-1)f[j] + f[i] - f[i-K+1]
//    所以 Sum(i) = Σ(j=i-K+1, i-1)f[j] 且 Sum(i+1) = Sum(i) + f[i] - f[i-K+1],
//    Sum(i) 可以代表第 i 头牛的方向是否发生反转,
//    可以在常数时间内计算出来, 复杂度降为O(n^2)
// ---------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace::std;
const int maxn = 5010;

int N;
int dir[maxn]; // 0:F, 1:B, 要全部反转为0
int f[maxn]; // f[i]:以i为起点的区间是否进行反转

// 对于给定的 K, 求对应的最小操作次数,
// 如果无解则返回 -1
int calc(int K) {
    memset(f, 0, sizeof(f));
    int res = 0, sum = 0; // sum: f求和, 第i头牛的方向是否发生反转

    // 反转前 N-K+1 头牛
    for (int i = 0; i + K <= N; i++) {
        if ((dir[i] + sum) % 2 != 0) {
            // 第一头牛为 B, 需要反转该区间
            res++;
            f[i] = 1;
        }
        sum += f[i];
        if (i - K + 1 >= 0) sum -= f[i - K + 1];
    }

    // 检查最后 K-1 头牛是否有 B
    for (int i = N - K + 1; i < N; ++i) {
        if ((dir[i] + sum) % 2 != 0) {
            return -1; // 还有牛为 B, 此方案不成立
        }
        if (i - K + 1 >= 0) sum -= f[i - K + 1];
    }

    return res;
}
void solve(void) {
    int K = 1, M = N; // 每次反转个数, 总反转次数
    for (int k = 1; k <= N; ++k) { // 枚举 K
        int m = calc(k);
        if (m >= 0 && m < M) { // 符合条件, 更新结果
            M = m;
            K = k;
        }
    }
    printf("%d %d\n", K, M);
}
int main(void) {
    while (scanf("%d", &N) != EOF) {
        memset(dir, 0, sizeof(dir));
        for (int i = 0; i < N; ++i) {
            getchar();
            char d = getchar();
            dir[i] = (d == 'B') ? 1 : 0;
        }
        solve();
    }
    return 0;
}