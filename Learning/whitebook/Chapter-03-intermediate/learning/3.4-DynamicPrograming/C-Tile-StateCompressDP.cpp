// ---------------------------------------------------------------------
// 题目描述:
// 给定 n*m 的格子, 每个格子被染成了黑色或者白色.
// 现要用 1*2 的砖块覆盖这些格子, 要求块与块之间不重叠, 且覆盖所有白色格子.
// 不能覆盖黑色格子.
// 求一共有多少种覆盖方法, 输出方案数对 M 取模后的结果.
// 1 <= n <= 15
// 1 <= m <= 15
// 2 <= M <= 10^9
// ---------------------------------------------------------------------
// 思路二:
// # # # # # #
// # # # # # #
// # # c x x x
// x x . . . .
// . . . . . .
// . . . . . .
// 按照思路一 BFS 的顺序, 假设现在来到了方块 c, 那么图中标为 '#' 的部分一定已经被访问过了.
// 而图中标为 '.' 的部分一定还没有被访问过.
// 所以需要关注的格子被压缩为图中被标为 'x' 的部分和 'c' 本身, 一共 m 个格子, 即 2^m 个状态.
// 可以用状态压缩编码进行记忆化搜索, 复杂度为O(n*m*2^m).
// ---------------------------------------------------------------------
const int M = 1e9 + 7;

// input
int n, m;
bool color[maxn][maxm]; // 0:白, 1:黑

// next:
// # # # c x x x
// x x x . . . .
// crt:
// # # # # c x x
// x x x x . . .
// next 和 crt 有 m-1 长度的重叠部分
int dp[2][1 << maxm]; // 滚动dp数组

void solve(void) {
    int *crt = dp[0], *next = dp[1];
    crt[0] = 1;
    for (int i = n - 1; i >= 0; i--) {
        for (int j = m - 1; j >= 0; j--) {
            for (int used = 0; used < (1 << m); used++) {
                if ((used >> j & 1) || color[i][j]) {
                    // 不需要放置砖块
                    next[used] = crt[used & ~(1 << j)];
                } else {
                    int res = 0;
                    // 横着放
                    if (j + 1 < m && !(used >> (j + 1) & 1) && !color[i][j + 1]) {
                        res += crt[used | 1 << (j + 1)];
                    }
                    // 竖着放
                    if (i + 1 < n && !color[i + 1][j]) {
                        res += crt[used | 1 << j];
                    }
                    next[used] = res % M;
                }
            }
            swap(crt, next);
        }
    }
    printf("%d\n", crt[0]);
}